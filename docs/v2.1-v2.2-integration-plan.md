# MIDIMon v2.1 GUI Integration + v2.2 Planning

**Created**: 2025-01-17
**Status**: Planning Phase
**Scope**: v2.1 GUI Integration (AMI-268-270) + v2.2 Feature Planning

---

## Executive Summary

This document outlines the dual-track approach for:
1. **Track 1**: Complete v2.1 GUI integration for SendMIDI action
2. **Track 2**: Plan v2.2 features (variable velocity, MIDI Learn, auto NoteOff)

Both tracks will proceed in parallel, with Track 1 being implementation work and Track 2 being planning/specification work.

---

## TRACK 1: v2.1 GUI Integration

### Current Status

**Backend**: ✅ 100% Complete
- MidiOutputManager implemented
- SendMIDI action types defined
- ActionExecutor integration complete
- 29 tests passing (100% pass rate)
- Documentation and examples complete

**GUI Infrastructure**: ✅ Exists
- Tauri v2 configured
- Svelte UI framework in place
- Existing Tauri commands pattern (`commands.rs`)
- State management (`state.rs`)
- API wrapper (`ui/src/lib/api.js`)

**Blocked Tasks**: 3 (AMI-268, AMI-269, AMI-270)

---

### AMI-268: Tauri Commands for MIDI Output

**Objective**: Add Tauri commands to expose MIDI output functionality to the GUI

**Estimated Effort**: 2 days

#### Tasks

1. **Add MIDI Output Port Listing Command**
   ```rust
   #[tauri::command]
   async fn list_midi_output_ports() -> Result<Vec<MidiOutputPort>, String>
   ```
   - Query MidiOutputManager for available ports
   - Return platform-specific port list
   - Handle virtual vs physical port distinction

2. **Add MIDI Output Test Command**
   ```rust
   #[tauri::command]
   async fn test_midi_output(
       port: String,
       message_type: String,
       channel: u8,
       params: MidiMessageParams
   ) -> Result<(), String>
   ```
   - Send a single test message to verify port connectivity
   - Used by GUI for "Test Output" button

3. **Add MIDI Output Validation Command**
   ```rust
   #[tauri::command]
   async fn validate_send_midi_action(action: SendMidiActionConfig) -> Result<ValidationResult, String>
   ```
   - Validate port exists
   - Validate message type and parameters
   - Return detailed error messages for UI display

4. **Update State Management**
   - Add `MidiOutputManager` to `AppState`
   - Initialize on app startup
   - Handle lifecycle (cleanup on shutdown)

#### Files to Modify

**`midimon-gui/src-tauri/src/commands.rs`**:
```rust
// Add to imports
use midimon_core::midi_output::MidiOutputManager;
use midimon_core::{MidiMessageType, MidiMessageParams};

// Add struct definitions
#[derive(Debug, Serialize, Deserialize)]
pub struct MidiOutputPort {
    pub index: usize,
    pub name: String,
    pub is_virtual: bool,
    pub platform: String, // "macOS", "Linux", "Windows"
}

// Add commands (3 functions ~150 lines total)
```

**`midimon-gui/src-tauri/src/state.rs`**:
```rust
// Add to AppState
pub struct AppState {
    // ... existing fields ...
    pub midi_output: Arc<Mutex<MidiOutputManager>>,
}
```

**`midimon-gui/src-tauri/src/main.rs`**:
```rust
// Register new commands
fn main() {
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![
            // ... existing commands ...
            list_midi_output_ports,
            test_midi_output,
            validate_send_midi_action,
        ])
        // ...
}
```

#### Testing Strategy

1. **Unit Tests** (commands.rs):
   - Test port listing on different platforms
   - Test message validation edge cases
   - Test error handling

2. **Manual Testing**:
   - Verify port list matches `aconnect -o` (Linux) or Audio MIDI Setup (macOS)
   - Send test messages to real/virtual ports
   - Verify error messages are user-friendly

---

### AMI-269: MidiOutputSelector Component

**Objective**: Create a Svelte component for selecting MIDI output ports

**Estimated Effort**: 1 day

#### Component Design

**Location**: `midimon-gui/ui/src/lib/components/MidiOutputSelector.svelte`

**Features**:
- Dropdown/select UI for available MIDI output ports
- Platform indicator (icon for macOS/Linux/Windows)
- Virtual port indicator (badge/icon)
- "Refresh" button to re-scan ports
- "Test Output" button to verify connectivity
- Error display for port connection failures

**Props**:
```typescript
export let selectedPort: string | null = null;
export let onPortChange: (port: string) => void;
export let disabled: boolean = false;
```

**API Calls**:
- `listMidiOutputPorts()` - Populate dropdown
- `testMidiOutput()` - Verify port works

#### UI Mockup (Text)

```
┌─────────────────────────────────────────────┐
│ MIDI Output Port                   [Refresh]│
│ ┌─────────────────────────────────────────┐ │
│ │ ▼ IAC Driver Bus 1 [macOS] [Virtual]   │ │
│ └─────────────────────────────────────────┘ │
│                                  [Test Port]│
│ ✅ Connected • Last tested: 2s ago          │
└─────────────────────────────────────────────┘
```

#### Implementation Tasks

1. **Create component skeleton**
2. **Add port fetching logic** (onMount + refresh)
3. **Add platform/virtual port badges**
4. **Add test output functionality**
5. **Add accessibility (ARIA labels, keyboard navigation)**
6. **Style with existing design system**

---

### AMI-270: SendMidiActionEditor Component

**Objective**: Create a Svelte component for editing SendMIDI actions in mappings

**Estimated Effort**: 1 day

#### Component Design

**Location**: `midimon-gui/ui/src/lib/components/SendMidiActionEditor.svelte`

**Features**:
- Message type selector (6 types: NoteOn, NoteOff, CC, ProgramChange, PitchBend, Aftertouch)
- Dynamic parameter fields based on message type
- MIDI channel selector (1-16, stored as 0-15)
- Port selector (uses MidiOutputSelector component)
- Real-time validation with error messages
- "Test Action" button to send once
- MIDI reference tooltips (CC numbers, note names, etc.)

**Props**:
```typescript
export let action: SendMidiActionConfig;
export let onChange: (action: SendMidiActionConfig) => void;
export let disabled: boolean = false;
```

**Dynamic Fields by Message Type**:

| Message Type | Fields |
|--------------|--------|
| NoteOn/NoteOff | Port, Channel, Note (0-127), Velocity (0-127) |
| ControlChange (CC) | Port, Channel, Controller (0-127), Value (0-127) |
| ProgramChange | Port, Channel, Program (0-127) |
| PitchBend | Port, Channel, Pitch (-8192 to +8191) |
| Aftertouch | Port, Channel, Pressure (0-127) |

#### UI Mockup (Text)

```
┌─────────────────────────────────────────────────────┐
│ SendMIDI Action Configuration                       │
├─────────────────────────────────────────────────────┤
│ Message Type:                                       │
│ ┌───────────────────┐                               │
│ │ ▼ Note On         │ ℹ Trigger a note with velocity│
│ └───────────────────┘                               │
│                                                     │
│ Output Port:                                        │
│ [MidiOutputSelector component]                      │
│                                                     │
│ MIDI Channel:                                       │
│ ┌────┐                                              │
│ │ 1  │ (1-16)                                       │
│ └────┘                                              │
│                                                     │
│ Note Number:                                        │
│ ┌────┐ C4 (Middle C)                                │
│ │ 60 │ [  Piano Roll  ]                             │
│ └────┘                                              │
│                                                     │
│ Velocity:                                           │
│ ┌─────┐                                             │
│ │ 100 │ ━━━━━●━━━━━━ Medium                         │
│ └─────┘                                             │
│                                                     │
│                          [Test Action] [Apply]      │
└─────────────────────────────────────────────────────┘
```

#### Implementation Tasks

1. **Create component skeleton**
2. **Add message type selector with descriptions**
3. **Implement dynamic field rendering**
4. **Add MIDI channel selector** (1-16 UI, 0-15 storage)
5. **Add note number picker** with piano roll visualization
6. **Add velocity slider** with visual feedback
7. **Add CC/program number selectors** with tooltips
8. **Add pitch bend slider** (-8192 to +8191)
9. **Integrate MidiOutputSelector**
10. **Add validation and error display**
11. **Add "Test Action" button**
12. **Add accessibility features**

---

### Integration Points

#### Existing Action Editor

**File**: `midimon-gui/ui/src/lib/components/ActionEditor.svelte` (or similar)

**Integration**:
```svelte
{#if action.type === 'SendMidi'}
  <SendMidiActionEditor
    action={action}
    onChange={handleActionChange}
    disabled={disabled}
  />
{:else if action.type === 'Keystroke'}
  <!-- Existing keystroke editor -->
{/if}
```

#### API Module

**File**: `midimon-gui/ui/src/lib/api.js`

**Add Functions**:
```javascript
export async function listMidiOutputPorts() {
  return await invoke('list_midi_output_ports');
}

export async function testMidiOutput(port, messageType, channel, params) {
  return await invoke('test_midi_output', { port, messageType, channel, params });
}

export async function validateSendMidiAction(action) {
  return await invoke('validate_send_midi_action', { action });
}
```

---

### Testing Plan

#### Unit Tests
- Tauri command validation (Rust)
- Component rendering (Svelte Testing Library)
- Message type switching logic
- Parameter validation

#### Integration Tests
- Full flow: Select port → Configure action → Test → Save
- Error handling: Invalid port, invalid parameters
- State management: Action persists across saves

#### Manual Testing Checklist
- [ ] Port list populates on all platforms
- [ ] Virtual ports are indicated
- [ ] All 6 message types work
- [ ] Parameter validation prevents invalid values
- [ ] Test button sends correct MIDI message
- [ ] Error messages are user-friendly
- [ ] Keyboard navigation works
- [ ] Screen reader friendly (ARIA labels)

---

## TRACK 2: v2.2 Feature Planning

### Priority Features (Top 3)

#### 1. Variable Velocity Mapping (P0 - Critical)

**Problem**: Users cannot map their controller's velocity to MIDI velocity dynamically. All MIDI velocities are static values in config.

**Use Case**:
```toml
# Current (v2.1) - static velocity
[action]
type = "SendMidi"
velocity = 100  # Always 100, regardless of how hard user hits pad

# Desired (v2.2) - dynamic velocity
[action]
type = "SendMidi"
velocity = "FromTrigger"  # Use incoming MIDI velocity
# OR
velocity = { source = "Trigger", multiplier = 0.8 }  # Scale velocity
```

**Implementation Complexity**: Medium
- Requires passing trigger velocity through action execution
- Need to design velocity mapping syntax (linear, curve, range mapping)
- Update ActionExecutor to accept runtime parameters

**Estimated Effort**: 3-4 days

**Impact**: High - Dramatically improves expressiveness

---

#### 2. Auto NoteOff (P0 - Critical)

**Problem**: Users must manually send NoteOff messages, leading to "stuck notes" if forgotten.

**Use Case**:
```toml
# Current (v2.1) - manual NoteOff required
[[modes.mappings]]
[modes.mappings.action]
type = "Sequence"
actions = [
    { type = "SendMidi", message_type = "NoteOn", note = 60, velocity = 100 },
    { type = "Delay", ms = 500 },
    { type = "SendMidi", message_type = "NoteOff", note = 60, velocity = 0 },
]

# Desired (v2.2) - auto NoteOff
[[modes.mappings]]
[modes.mappings.action]
type = "SendMidi"
message_type = "NoteOn"
note = 60
velocity = 100
duration_ms = 500  # Auto-send NoteOff after 500ms
```

**Implementation Complexity**: Medium-High
- Requires timer/scheduler for delayed NoteOff
- Must handle edge cases (note retriggered before NoteOff)
- Should support "hold until trigger release" mode

**Estimated Effort**: 4-5 days

**Impact**: High - Prevents stuck notes, improves UX

---

#### 3. MIDI Learn Mode (P1 - High Priority)

**Problem**: Manually typing note numbers and CC values is tedious and error-prone.

**Use Case**:
1. User clicks "MIDI Learn" button in GUI
2. User presses pad/turns knob on controller
3. Trigger is auto-filled with correct note/CC/direction
4. User configures action
5. Done!

**Implementation Complexity**: High
- Requires GUI-daemon communication for learn mode
- Need to distinguish "learn" events from normal operation
- Should support timeout (exit learn mode after 10s)
- Must handle edge cases (wrong device sends MIDI)

**Estimated Effort**: 5-7 days

**Impact**: Very High - Dramatically improves onboarding UX

**Note**: Some MIDI Learn infrastructure already exists (`midi_learn.rs`)

---

### Secondary Features

#### 4. CC Value Incremental Mapping (P2)

**Problem**: Encoder rotations currently send fixed CC values (0 or 127), not incremental changes.

```toml
# Desired
[action]
type = "SendMidi"
message_type = "CC"
controller = 7  # Volume
value_mode = "Increment"  # Send +1 or -1 based on encoder direction
# OR
value_mode = { mode = "Step", step = 5 }  # Send +5 or -5
```

**Estimated Effort**: 2-3 days

---

#### 5. SysEx Support (P3)

**Problem**: Some hardware synths require SysEx for preset changes, parameter control.

```toml
[action]
type = "SendMidi"
message_type = "SysEx"
data = [0xF0, 0x43, 0x10, 0x00, 0x01, 0x00, 0xF7]  # Yamaha bank change
```

**Estimated Effort**: 2-3 days

---

#### 6. MIDI Clock/Sync (P3)

**Problem**: Cannot sync external gear to DAW tempo.

**Implementation**: Send MIDI Clock (0xF8), Start (0xFA), Stop (0xFC)

**Estimated Effort**: 3-4 days

---

### v2.2 Timeline Estimate

| Feature | Priority | Effort | Dependencies |
|---------|----------|--------|--------------|
| Variable Velocity | P0 | 3-4 days | None |
| Auto NoteOff | P0 | 4-5 days | None |
| MIDI Learn | P1 | 5-7 days | GUI infrastructure |
| CC Incremental | P2 | 2-3 days | Variable Velocity |
| SysEx Support | P3 | 2-3 days | None |
| MIDI Clock | P3 | 3-4 days | Timer system |

**Total Estimate**: 19-26 days (4-5 weeks)

**Recommended v2.2 Scope**: P0 + P1 features only (12-16 days, ~3 weeks)

---

### v2.2 Design Decisions

#### Variable Velocity - Syntax Options

**Option A: String-based** (Simple)
```toml
velocity = "FromTrigger"  # Direct passthrough
velocity = "Scaled_50"    # Scale to 50% of trigger
```

**Option B: Object-based** (Flexible)
```toml
[action.velocity]
source = "Trigger"
multiplier = 0.8  # 80% of trigger velocity
offset = 10       # Add 10 to result
clamp_min = 20
clamp_max = 120
```

**Option C: Curve-based** (Most powerful)
```toml
[action.velocity]
source = "Trigger"
curve = "Logarithmic"  # Or "Linear", "Exponential", "Custom"
range_in = [0, 127]
range_out = [40, 127]  # Never send velocity < 40
```

**Recommendation**: Start with Option A for v2.2.0, add Option B in v2.2.1

---

#### Auto NoteOff - Modes

**Mode 1: Fixed Duration**
```toml
duration_ms = 500  # NoteOff after 500ms
```

**Mode 2: Hold Until Release** (Requires trigger release detection)
```toml
duration = "UntilRelease"  # NoteOff when pad is released
```

**Mode 3: Combined**
```toml
duration_mode = "Release"
max_duration_ms = 2000  # Force NoteOff after 2s even if still held
```

**Recommendation**: Start with Mode 1 for v2.2.0, add Mode 2 in v2.2.1

---

## Implementation Roadmap

### Phase 1: v2.1 GUI (Week 1-2)

**Week 1**:
- Day 1-2: AMI-268 (Tauri commands)
- Day 3: AMI-269 (MidiOutputSelector component)
- Day 4-5: AMI-270 (SendMidiActionEditor component)

**Week 2**:
- Day 1-2: Integration testing
- Day 3: Manual testing with real devices
- Day 4: Bug fixes
- Day 5: Documentation updates

---

### Phase 2: v2.2 Backend (Week 3-5)

**Week 3**:
- Day 1-3: Variable Velocity implementation
- Day 4-5: Variable Velocity testing

**Week 4**:
- Day 1-4: Auto NoteOff implementation
- Day 5: Auto NoteOff testing

**Week 5**:
- Day 1-5: MIDI Learn mode implementation

**Week 6**:
- Day 1-2: MIDI Learn testing
- Day 3-4: Integration testing
- Day 5: Documentation

---

### Phase 3: v2.2 GUI (Week 7)

**Week 7**:
- Day 1-2: Update SendMidiActionEditor for new features
- Day 3-4: MIDI Learn UI
- Day 5: Final integration and testing

---

## Success Metrics

### v2.1 GUI Completion
- [ ] All 3 AMI tasks (268-270) complete
- [ ] SendMIDI action editable in GUI
- [ ] Port selection works on all platforms
- [ ] Test button verifies connectivity
- [ ] Zero critical bugs in production testing

### v2.2 Feature Completion
- [ ] Variable velocity works with all trigger types
- [ ] Auto NoteOff prevents stuck notes
- [ ] MIDI Learn reduces config time by 80%
- [ ] Documentation updated
- [ ] All new tests passing (target: 50+ new tests)

---

## Risk Assessment

### v2.1 GUI Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Platform-specific port issues | Medium | Medium | Test on all 3 platforms early |
| GUI state management complexity | Low | Medium | Use existing patterns |
| Tauri IPC overhead | Low | Low | Batch operations where possible |

### v2.2 Feature Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Variable velocity config too complex | Medium | High | Start simple, iterate |
| Auto NoteOff timer accuracy | Medium | Medium | Use proven timer library |
| MIDI Learn conflicts with normal operation | High | High | Clear mode indication in UI |
| Scope creep (adding too many features) | High | High | Stick to P0+P1 only for v2.2.0 |

---

## Next Actions

### Immediate (Today)
1. Review and approve this plan
2. Create Linear issues for AMI-268, AMI-269, AMI-270
3. Set up development branch: `feature/v2.1-gui-integration`

### This Week
1. Implement AMI-268 (Tauri commands)
2. Begin AMI-269 (MidiOutputSelector)
3. Draft v2.2 feature specs (1-page each)

### Next Week
1. Complete AMI-269 and AMI-270
2. Begin integration testing
3. Finalize v2.2.0 scope and create Linear issues

---

## Appendix A: Linear Issue Templates

### AMI-268 Template
```markdown
Title: [v2.1 GUI] Add Tauri commands for MIDI output management

Description:
Implement Tauri commands to expose MIDI output functionality to GUI.

Tasks:
- [ ] Add list_midi_output_ports command
- [ ] Add test_midi_output command
- [ ] Add validate_send_midi_action command
- [ ] Update AppState with MidiOutputManager
- [ ] Register commands in main.rs
- [ ] Write unit tests (3 tests minimum)

Acceptance Criteria:
- Commands callable from JS/Svelte
- Port list includes platform and virtual port indicators
- Test command successfully sends MIDI
- Validation catches all error cases

Estimate: 2 days
Priority: P0
Labels: v2.1, GUI, Backend
```

---

## Appendix B: File Structure

```
midimon-gui/
├── src-tauri/
│   └── src/
│       ├── commands.rs           # Modified (AMI-268)
│       ├── state.rs              # Modified (AMI-268)
│       └── main.rs               # Modified (AMI-268)
└── ui/
    └── src/
        ├── lib/
        │   ├── api.js            # Modified (all AMIs)
        │   └── components/
        │       ├── MidiOutputSelector.svelte      # NEW (AMI-269)
        │       └── SendMidiActionEditor.svelte    # NEW (AMI-270)
        └── App.svelte            # Modified (integration)
```

---

*End of Plan*
