# v2.7 Plugin Signing/Verification - Design Document

**Date:** 2025-01-19
**Status:** üìù Design Phase
**Version:** v2.7 (Medium Term Task 3/3)

---

## Overview

Design and implement cryptographic signing and verification for WASM plugins to ensure authenticity and integrity. This prevents tampering and establishes a trust chain for plugin distribution.

## Goals

1. **Authenticity:** Verify plugins are signed by trusted developers
2. **Integrity:** Detect any tampering with plugin binaries
3. **Trust Chain:** Establish developer identity verification
4. **Performance:** Minimal overhead (<10ms verification time)
5. **Developer UX:** Simple signing workflow for plugin authors

---

## Cryptographic Design

### Algorithm: Ed25519 Digital Signatures

**Why Ed25519?**
- ‚úÖ Fast verification (~0.1ms per signature)
- ‚úÖ Small signatures (64 bytes)
- ‚úÖ Small keys (32 bytes public, 64 bytes private)
- ‚úÖ Industry standard (used by Signal, Tor, SSH)
- ‚úÖ Collision-resistant
- ‚úÖ No side-channel vulnerabilities

**Alternative Considered:**
- ‚ùå RSA-2048: Larger keys (256 bytes), slower verification (~2ms)
- ‚ùå ECDSA P-256: More complex, not constant-time

### Signature Format

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  WASM Plugin File (.wasm)                       ‚îÇ
‚îÇ  - WebAssembly binary                           ‚îÇ
‚îÇ  - Exports: init(), execute()                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
                     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Signature File (.wasm.sig)                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ  Signature Metadata (JSON)                ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  {                                        ‚îÇ ‚îÇ
‚îÇ  ‚îÇ    "version": 1,                          ‚îÇ ‚îÇ
‚îÇ  ‚îÇ    "algorithm": "Ed25519",                ‚îÇ ‚îÇ
‚îÇ  ‚îÇ    "plugin_hash": "sha256:...",           ‚îÇ ‚îÇ
‚îÇ  ‚îÇ    "plugin_size": 68000,                  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ    "public_key": "hex...",                ‚îÇ ‚îÇ
‚îÇ  ‚îÇ    "signature": "hex...",                 ‚îÇ ‚îÇ
‚îÇ  ‚îÇ    "signed_at": "2025-01-19T...",         ‚îÇ ‚îÇ
‚îÇ  ‚îÇ    "developer": {                         ‚îÇ ‚îÇ
‚îÇ  ‚îÇ      "name": "Amiable Team",              ‚îÇ ‚îÇ
‚îÇ  ‚îÇ      "email": "dev@amiable.com"           ‚îÇ ‚îÇ
‚îÇ  ‚îÇ    }                                      ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  }                                        ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Architecture

### Components

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Plugin Developer Workflow                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ  1. Build plugin: cargo build --release  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  2. Generate keypair (once): sign-plugin ‚îÇ ‚îÇ
‚îÇ  ‚îÇ     --generate-key                        ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  3. Sign plugin: sign-plugin             ‚îÇ ‚îÇ
‚îÇ  ‚îÇ     plugin.wasm --key private.key         ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  4. Distribute: plugin.wasm + .wasm.sig  ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
                     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Runtime Verification (WasmPlugin::load)        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ  1. Load plugin.wasm                      ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  2. Load plugin.wasm.sig                  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  3. Verify signature matches hash         ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  4. Check trusted keys list               ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  5. Load if verified, reject otherwise    ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### File Structure

```
plugins/
  wasm-spotify/
    target/wasm32-wasip1/release/
      midimon_wasm_spotify.wasm        # Plugin binary
      midimon_wasm_spotify.wasm.sig    # Signature file (JSON)

~/.config/midimon/
  trusted_keys.toml                    # List of trusted public keys
```

---

## Implementation Plan

### Phase 1: Signing Tool (midimon-sign CLI)

Create a standalone CLI tool for plugin developers:

**Location:** `midimon-core/src/bin/midimon-sign.rs`

**Commands:**
```bash
# Generate Ed25519 keypair
midimon-sign generate-key --output ~/.midimon/signing.key

# Sign a plugin
midimon-sign sign plugin.wasm --key ~/.midimon/signing.key

# Verify a plugin signature
midimon-sign verify plugin.wasm
```

**Key Generation:**
```rust
use ed25519_dalek::{SigningKey, VerifyingKey};
use rand::rngs::OsRng;

let signing_key = SigningKey::generate(&mut OsRng);
let verifying_key = signing_key.verifying_key();

// Save to file (PEM format)
std::fs::write("private.key", signing_key.to_bytes())?;
std::fs::write("public.key", verifying_key.to_bytes())?;
```

**Signing Process:**
```rust
use ed25519_dalek::{Signature, Signer, SigningKey};
use sha2::{Sha256, Digest};

// Read plugin binary
let plugin_bytes = std::fs::read("plugin.wasm")?;

// Compute SHA-256 hash
let mut hasher = Sha256::new();
hasher.update(&plugin_bytes);
let plugin_hash = hasher.finalize();

// Sign the hash
let signing_key = SigningKey::from_bytes(&load_key("private.key")?);
let signature: Signature = signing_key.sign(&plugin_hash);

// Create signature file
let sig_metadata = SignatureMetadata {
    version: 1,
    algorithm: "Ed25519".to_string(),
    plugin_hash: hex::encode(plugin_hash),
    plugin_size: plugin_bytes.len() as u64,
    public_key: hex::encode(signing_key.verifying_key().to_bytes()),
    signature: hex::encode(signature.to_bytes()),
    signed_at: chrono::Utc::now(),
    developer: DeveloperInfo { ... },
};

std::fs::write("plugin.wasm.sig", serde_json::to_string_pretty(&sig_metadata)?)?;
```

---

### Phase 2: Verification in Runtime

Update `WasmPlugin::load()` to verify signatures:

**Location:** `midimon-core/src/plugin/wasm_runtime.rs`

**Verification Process:**
```rust
pub async fn load(path: &Path, config: WasmConfig) -> Result<Self, EngineError> {
    // Load signature file
    let sig_path = path.with_extension("wasm.sig");
    if sig_path.exists() {
        verify_plugin_signature(path, &sig_path)?;
    } else if config.require_signature {
        return Err(EngineError::PluginLoadFailed(
            "Plugin signature required but not found".to_string()
        ));
    }

    // Continue with existing load logic...
}

fn verify_plugin_signature(plugin_path: &Path, sig_path: &Path) -> Result<(), EngineError> {
    // Read signature metadata
    let sig_json = std::fs::read_to_string(sig_path)
        .map_err(|e| EngineError::PluginLoadFailed(format!("Failed to read signature: {}", e)))?;
    let sig_metadata: SignatureMetadata = serde_json::from_str(&sig_json)
        .map_err(|e| EngineError::PluginLoadFailed(format!("Invalid signature format: {}", e)))?;

    // Read plugin binary
    let plugin_bytes = std::fs::read(plugin_path)
        .map_err(|e| EngineError::PluginLoadFailed(format!("Failed to read plugin: {}", e)))?;

    // Verify file size matches
    if plugin_bytes.len() as u64 != sig_metadata.plugin_size {
        return Err(EngineError::PluginLoadFailed("Plugin size mismatch".to_string()));
    }

    // Compute hash
    let mut hasher = Sha256::new();
    hasher.update(&plugin_bytes);
    let computed_hash = hex::encode(hasher.finalize());

    // Verify hash matches
    if computed_hash != sig_metadata.plugin_hash {
        return Err(EngineError::PluginLoadFailed("Plugin hash mismatch".to_string()));
    }

    // Decode public key and signature
    let public_key_bytes = hex::decode(&sig_metadata.public_key)
        .map_err(|e| EngineError::PluginLoadFailed(format!("Invalid public key: {}", e)))?;
    let signature_bytes = hex::decode(&sig_metadata.signature)
        .map_err(|e| EngineError::PluginLoadFailed(format!("Invalid signature: {}", e)))?;

    // Verify signature
    use ed25519_dalek::{Signature, Verifier, VerifyingKey};

    let verifying_key = VerifyingKey::from_bytes(&public_key_bytes.try_into().unwrap())
        .map_err(|e| EngineError::PluginLoadFailed(format!("Invalid key format: {}", e)))?;
    let signature = Signature::from_bytes(&signature_bytes.try_into().unwrap());

    verifying_key.verify(&hex::decode(&computed_hash).unwrap(), &signature)
        .map_err(|_| EngineError::PluginLoadFailed("Signature verification failed".to_string()))?;

    // Check if public key is trusted
    let trusted_keys = load_trusted_keys()?;
    if !trusted_keys.contains(&sig_metadata.public_key) {
        return Err(EngineError::PluginLoadFailed(
            format!("Plugin signed by untrusted key: {}", sig_metadata.developer.name)
        ));
    }

    Ok(())
}
```

---

### Phase 3: Trusted Keys Management

**File:** `~/.config/midimon/trusted_keys.toml`

```toml
# Trusted plugin developer public keys
[[keys]]
name = "Amiable Team"
email = "dev@amiable.com"
public_key = "a1b2c3d4..."
added_at = "2025-01-19T10:00:00Z"

[[keys]]
name = "Community Developer"
email = "dev@example.com"
public_key = "e5f6g7h8..."
added_at = "2025-01-20T15:30:00Z"
```

**Trust Management Commands:**
```bash
# Add trusted key
midimon-sign trust add --key a1b2c3d4... --name "Developer Name"

# List trusted keys
midimon-sign trust list

# Remove trusted key
midimon-sign trust remove --key a1b2c3d4...
```

---

## Configuration Options

### WasmConfig Extensions

```rust
pub struct WasmConfig {
    pub max_memory_bytes: u64,
    pub max_execution_time: Duration,
    pub max_fuel: u64,
    pub capabilities: Vec<Capability>,

    // NEW: Signature verification settings
    pub require_signature: bool,        // Reject unsigned plugins
    pub allow_self_signed: bool,        // Allow plugins signed by any key
    pub trusted_keys_path: Option<PathBuf>,  // Custom trusted keys file
}

impl Default for WasmConfig {
    fn default() -> Self {
        Self {
            // ... existing defaults ...
            require_signature: true,      // Enforce signatures by default
            allow_self_signed: false,     // Require trusted keys
            trusted_keys_path: None,      // Use default ~/.config/midimon/trusted_keys.toml
        }
    }
}
```

---

## Security Considerations

### Threat Model

**Threats Mitigated:**
1. ‚úÖ Malicious plugin substitution (prevents binary tampering)
2. ‚úÖ Man-in-the-middle attacks (signature ensures authenticity)
3. ‚úÖ Supply chain attacks (trust chain via public keys)

**Threats NOT Mitigated:**
1. ‚ö†Ô∏è Compromised developer keys (requires key rotation)
2. ‚ö†Ô∏è Side-channel attacks (Ed25519 is constant-time)
3. ‚ö†Ô∏è Social engineering (users must verify developer identity)

### Key Management Best Practices

**For Developers:**
- üîê Store private keys in secure location (not version control!)
- üîê Use password-protected key storage (future enhancement)
- üîê Rotate keys annually
- üîê Publish public key fingerprint on official website

**For Users:**
- ‚úÖ Only trust keys from verified sources
- ‚úÖ Verify developer identity before adding trusted key
- ‚úÖ Review trusted keys list periodically
- ‚úÖ Remove unused trusted keys

---

## Developer Workflow

### First-Time Setup

```bash
# 1. Generate signing keypair
cd ~/.midimon
midimon-sign generate-key --output signing.key

# 2. Add public key to repository (for users to verify)
cat signing.key.pub >> PLUGIN_PUBLIC_KEY.txt
```

### Per-Plugin Signing

```bash
# Build plugin
cd plugins/wasm-spotify
cargo build --target wasm32-wasip1 --release

# Sign plugin
midimon-sign sign \
  target/wasm32-wasip1/release/midimon_wasm_spotify.wasm \
  --key ~/.midimon/signing.key \
  --name "Amiable Team" \
  --email "dev@amiable.com"

# Verify signature
midimon-sign verify target/wasm32-wasip1/release/midimon_wasm_spotify.wasm

# Distribute both files
ls target/wasm32-wasip1/release/midimon_wasm_spotify.*
# midimon_wasm_spotify.wasm
# midimon_wasm_spotify.wasm.sig
```

---

## User Workflow

### Installing Signed Plugin

```bash
# Download plugin and signature
wget https://example.com/plugins/spotify.wasm
wget https://example.com/plugins/spotify.wasm.sig

# Verify developer public key (one-time)
midimon-sign trust add \
  --key a1b2c3d4e5f6... \
  --name "Amiable Team" \
  --verify-url https://amiable.com/pgp

# Plugin automatically verified on load
# (WasmPlugin::load checks signature and trusted keys)
```

---

## Performance Benchmarks

### Target Metrics

| Operation | Target | Expected |
|-----------|--------|----------|
| Key generation | <100ms | ~50ms |
| Signing | <10ms | ~5ms |
| Verification | <10ms | ~2ms |
| File I/O overhead | <5ms | ~2ms |
| **Total load overhead** | **<15ms** | **~10ms** |

### Benchmark Plan

Create `benches/plugin_signing.rs`:

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn benchmark_signing(c: &mut Criterion) {
    let plugin_bytes = std::fs::read("test_plugin.wasm").unwrap();

    c.bench_function("sign_plugin", |b| {
        b.iter(|| {
            sign_plugin_bytes(black_box(&plugin_bytes))
        });
    });

    c.bench_function("verify_signature", |b| {
        let signature = sign_plugin_bytes(&plugin_bytes);
        b.iter(|| {
            verify_plugin_signature(black_box(&plugin_bytes), black_box(&signature))
        });
    });
}

criterion_group!(benches, benchmark_signing);
criterion_main!(benches);
```

---

## Testing Strategy

### Unit Tests

1. **Key Generation:**
   - Generate valid Ed25519 keypair
   - Keys are 32 bytes (public) and 64 bytes (private)

2. **Signing:**
   - Sign plugin binary produces 64-byte signature
   - Same plugin + key = deterministic signature
   - Different plugins = different signatures

3. **Verification:**
   - Valid signature passes verification
   - Tampered binary fails verification
   - Wrong public key fails verification
   - Invalid signature format fails

### Integration Tests

1. **End-to-End Workflow:**
   - Generate key ‚Üí Sign plugin ‚Üí Verify signature
   - Load signed plugin successfully
   - Reject unsigned plugin (if require_signature=true)
   - Reject tampered plugin

2. **Trust Management:**
   - Add trusted key
   - Load plugin with trusted key
   - Reject plugin with untrusted key

### Test Files

- `tests/plugin_signing_test.rs` (10 tests)
- `benches/plugin_signing.rs` (performance)

---

## Dependencies

### New Crate: ed25519-dalek

Add to `Cargo.toml`:

```toml
[dependencies]
ed25519-dalek = { version = "2.1", features = ["rand_core"] }
hex = "0.4"  # For encoding/decoding signatures

# Already available:
sha2 = "0.10"  # SHA-256 hashing
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
```

**Why ed25519-dalek?**
- ‚úÖ Pure Rust implementation
- ‚úÖ Constant-time operations (no side channels)
- ‚úÖ Active maintenance (latest: 2.1.1)
- ‚úÖ Used by Signal, Tor, libsodium
- ‚úÖ Fast: 64,000 verifications/second

---

## Migration Path

### Phase 1: Optional Signatures (v2.7.0)

- Signatures are verified if present
- Unsigned plugins still load (backward compatible)
- `WasmConfig::require_signature = false` by default

### Phase 2: Recommended Signatures (v2.8.0)

- Warning message for unsigned plugins
- Official plugins ship with signatures
- Documentation encourages signing

### Phase 3: Required Signatures (v3.0.0)

- `WasmConfig::require_signature = true` by default
- Unsigned plugins rejected by default
- Override with `allow_unsigned = true` config flag

---

## Future Enhancements

### 1. Key Rotation

Support multiple keys per developer:

```toml
[[keys]]
name = "Amiable Team"
current_key = "a1b2c3d4..."
deprecated_keys = ["e5f6g7h8..."]  # Still trusted but not for new signatures
```

### 2. Timestamp Verification

Add timestamp server to prevent replay attacks:

```json
{
  "signature": "...",
  "timestamp": {
    "server": "https://timestamp.amiable.com",
    "token": "...",
    "verified_at": "2025-01-19T..."
  }
}
```

### 3. Certificate Chains

Support hierarchical trust (root ‚Üí intermediate ‚Üí developer):

```
Root CA (Amiable)
  ‚îî‚îÄ Intermediate CA (Plugin Marketplace)
      ‚îî‚îÄ Developer Key (Plugin Author)
```

### 4. Password-Protected Keys

Encrypt private keys with password:

```bash
midimon-sign generate-key --password
# Enter password: ****
```

---

## Success Criteria

| Metric | Target | Status |
|--------|--------|--------|
| Signing tool implemented | CLI with 3 commands | ‚è≥ |
| Verification in runtime | WasmPlugin::load | ‚è≥ |
| Unit tests | 10+ tests, 100% pass | ‚è≥ |
| Integration tests | 5+ tests, 100% pass | ‚è≥ |
| Performance | <10ms verification | ‚è≥ |
| Documentation | Complete guide | ‚è≥ |
| Example signed plugins | 3 official plugins | ‚è≥ |

---

## Conclusion

This design provides a robust, performant, and user-friendly plugin signing system using industry-standard Ed25519 cryptography. It balances security with developer experience and provides a clear migration path from optional to required signatures.

**Next Steps:**
1. Implement `midimon-sign` CLI tool
2. Update `WasmPlugin::load()` with verification
3. Create comprehensive test suite
4. Sign official plugins (Spotify, OBS, System Utils)
5. Document signing workflow

---

**Questions?** See the [WASM Plugin Development Guide](WASM_PLUGIN_DEVELOPMENT_GUIDE.md)
**Want to contribute?** See [CONTRIBUTING.md](../CONTRIBUTING.md)
**Need help?** Check the Ed25519 documentation
