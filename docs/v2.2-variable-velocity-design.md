# v2.2 Variable Velocity - Design Document

**Date**: 2025-01-17
**Status**: DESIGN PHASE
**Feature**: Dynamic velocity mapping for SendMIDI actions
**Estimated Effort**: 3-4 days
**Priority**: Priority 0 (High Value, Core Functionality)

---

## Executive Summary

Variable Velocity enables SendMIDI actions to map the trigger velocity to the output MIDI velocity dynamically. Instead of sending a fixed velocity value (e.g., always 100), the system will:

- **Preserve trigger velocity** → Pass-through mode (trigger velocity = output velocity)
- **Scale trigger velocity** → Linear mapping (e.g., input 0-127 → output 50-100)
- **Transform trigger velocity** → Curve-based mapping (e.g., exponential, logarithmic)
- **Fixed velocity** → Current behavior (always send specified value)

This feature enables expressive MIDI control where pad dynamics are preserved when sending MIDI notes to DAWs or synthesizers.

---

## Use Cases

### Use Case 1: Pass-Through Dynamics
**Scenario**: User wants to play virtual drums in a DAW with natural dynamics.

**Current Behavior**:
- Trigger pad with velocity 80 → Send MIDI Note On with velocity 100 (fixed)
- Trigger pad with velocity 120 → Send MIDI Note On with velocity 100 (fixed)
- **Result**: No expressive control, all hits sound the same

**With Variable Velocity**:
- Trigger pad with velocity 80 → Send MIDI Note On with velocity 80
- Trigger pad with velocity 120 → Send MIDI Note On with velocity 120
- **Result**: Full expressive control, dynamics preserved

---

### Use Case 2: Scaled Dynamics
**Scenario**: User wants to limit output velocity range to avoid clipping in soft synth.

**Current Behavior**:
- Hard hit (velocity 127) → MIDI velocity 100
- Soft hit (velocity 30) → MIDI velocity 100
- **Result**: No dynamic range

**With Variable Velocity** (scale to 50-100 range):
- Hard hit (velocity 127) → MIDI velocity 100
- Medium hit (velocity 63) → MIDI velocity 75
- Soft hit (velocity 0) → MIDI velocity 50
- **Result**: Controlled dynamic range without clipping

---

### Use Case 3: Curve Transformation
**Scenario**: User wants to make soft hits louder for better control.

**With Variable Velocity** (exponential curve):
- Input velocity 30 → Output velocity 60 (doubled)
- Input velocity 60 → Output velocity 90 (1.5x)
- Input velocity 127 → Output velocity 127 (preserved)
- **Result**: More expressive soft hits, easier to play dynamically

---

## Architectural Design

### 1. Data Structures

#### VelocityMapping Enum

```rust
// midimon-core/src/actions.rs

/// Velocity mapping mode for SendMIDI actions (v2.2)
///
/// Defines how trigger velocity is mapped to output MIDI velocity.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum VelocityMapping {
    /// Fixed velocity (current behavior)
    /// Always send the same velocity regardless of trigger velocity
    Fixed {
        velocity: u8,  // 0-127
    },

    /// Pass-through mode (1:1 mapping)
    /// Output velocity = trigger velocity
    PassThrough,

    /// Linear scaling with configurable range
    /// Maps input range (0-127) to output range (min-max)
    Linear {
        min: u8,  // Minimum output velocity (0-127)
        max: u8,  // Maximum output velocity (0-127)
    },

    /// Curve-based transformation
    /// Applies non-linear curve to velocity values
    Curve {
        curve_type: VelocityCurve,
        intensity: f32,  // 0.0-1.0, curve strength
    },
}

/// Velocity curve types for non-linear transformations
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub enum VelocityCurve {
    /// Exponential curve (soft hits louder)
    /// Output = input ^ (1 + intensity)
    Exponential,

    /// Logarithmic curve (soft hits quieter)
    /// Output = log(1 + input * intensity) / log(1 + 127 * intensity) * 127
    Logarithmic,

    /// S-curve (sigmoid) for smooth transitions
    /// Output = 127 / (1 + exp(-intensity * (input - 63.5)))
    SCurve,
}
```

---

#### Updated MidiMessageParams

```rust
// midimon-core/src/actions.rs

/// MIDI message parameters (v2.2 - updated for variable velocity)
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum MidiMessageParams {
    Note {
        note: u8,
        velocity_mapping: VelocityMapping,  // NEW: was `velocity: u8`
    },
    CC {
        controller: u8,
        value: u8,  // Could support ValueMapping in future
    },
    ProgramChange {
        program: u8,
    },
    PitchBend {
        value: i16,  // -8192 to +8191
    },
    Aftertouch {
        pressure: u8,
    },
}
```

---

### 2. Velocity Calculation Engine

```rust
// midimon-core/src/velocity.rs (NEW FILE)

//! Velocity mapping and calculation engine.
//!
//! Provides functions to map trigger velocity to output velocity
//! based on VelocityMapping configuration.

use crate::actions::{VelocityMapping, VelocityCurve};

/// Calculate output velocity based on trigger velocity and mapping config
///
/// # Arguments
/// * `trigger_velocity` - Input velocity from trigger event (0-127)
/// * `mapping` - Velocity mapping configuration
///
/// # Returns
/// * Output MIDI velocity (0-127)
///
/// # Examples
/// ```
/// use midimon_core::velocity::calculate_velocity;
/// use midimon_core::actions::VelocityMapping;
///
/// // Pass-through mode
/// let output = calculate_velocity(80, &VelocityMapping::PassThrough);
/// assert_eq!(output, 80);
///
/// // Linear scaling (0-127 → 50-100)
/// let output = calculate_velocity(127, &VelocityMapping::Linear { min: 50, max: 100 });
/// assert_eq!(output, 100);
/// ```
pub fn calculate_velocity(trigger_velocity: u8, mapping: &VelocityMapping) -> u8 {
    match mapping {
        VelocityMapping::Fixed { velocity } => *velocity,

        VelocityMapping::PassThrough => trigger_velocity,

        VelocityMapping::Linear { min, max } => {
            // Linear interpolation: output = min + (trigger / 127) * (max - min)
            let normalized = trigger_velocity as f32 / 127.0;
            let range = (*max as f32) - (*min as f32);
            let output = (*min as f32) + (normalized * range);
            output.round().clamp(0.0, 127.0) as u8
        }

        VelocityMapping::Curve { curve_type, intensity } => {
            apply_curve(trigger_velocity, *curve_type, *intensity)
        }
    }
}

/// Apply non-linear curve transformation to velocity
fn apply_curve(input: u8, curve_type: VelocityCurve, intensity: f32) -> u8 {
    let normalized = input as f32 / 127.0;  // 0.0-1.0

    let output = match curve_type {
        VelocityCurve::Exponential => {
            // Exponential: y = x^(1 + intensity)
            // intensity 0.0 → linear, 1.0 → square (soft hits louder)
            normalized.powf(1.0 + intensity)
        }

        VelocityCurve::Logarithmic => {
            // Logarithmic: y = log(1 + x*k) / log(1 + k)
            // where k = intensity * 127
            let k = intensity * 127.0;
            if k < 0.01 {
                normalized  // Avoid division by zero
            } else {
                (1.0 + normalized * k).ln() / (1.0 + k).ln()
            }
        }

        VelocityCurve::SCurve => {
            // Sigmoid S-curve: y = 1 / (1 + exp(-intensity * (x - 0.5)))
            // intensity controls steepness
            let k = intensity * 10.0;  // Scale intensity for usable range
            1.0 / (1.0 + (-k * (normalized - 0.5)).exp())
        }
    };

    (output * 127.0).round().clamp(0.0, 127.0) as u8
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fixed_velocity() {
        let mapping = VelocityMapping::Fixed { velocity: 100 };
        assert_eq!(calculate_velocity(0, &mapping), 100);
        assert_eq!(calculate_velocity(63, &mapping), 100);
        assert_eq!(calculate_velocity(127, &mapping), 100);
    }

    #[test]
    fn test_passthrough() {
        let mapping = VelocityMapping::PassThrough;
        assert_eq!(calculate_velocity(0, &mapping), 0);
        assert_eq!(calculate_velocity(63, &mapping), 63);
        assert_eq!(calculate_velocity(127, &mapping), 127);
    }

    #[test]
    fn test_linear_scaling() {
        let mapping = VelocityMapping::Linear { min: 50, max: 100 };
        assert_eq!(calculate_velocity(0, &mapping), 50);
        assert_eq!(calculate_velocity(127, &mapping), 100);

        // Middle value: 63.5 → (50 + 75) / 2 ≈ 75
        let mid = calculate_velocity(63, &mapping);
        assert!(mid >= 74 && mid <= 76);
    }

    #[test]
    fn test_exponential_curve() {
        let mapping = VelocityMapping::Curve {
            curve_type: VelocityCurve::Exponential,
            intensity: 0.5,
        };

        // Exponential curve makes soft hits louder
        let soft = calculate_velocity(30, &mapping);
        let linear_soft = (30.0 / 127.0 * 127.0) as u8;
        assert!(soft > linear_soft);

        // Hard hits stay close to max
        assert_eq!(calculate_velocity(127, &mapping), 127);
    }
}
```

---

### 3. Action Execution Integration

```rust
// midimon-daemon/src/action_executor.rs (modifications)

impl ActionExecutor {
    pub fn execute(&mut self, action: &Action, trigger_velocity: Option<u8>) -> Result<()> {
        match action {
            Action::SendMidi { port, message_type, channel, params } => {
                self.execute_send_midi(port, *message_type, *channel, params, trigger_velocity)?;
            }
            // ... other actions
        }
        Ok(())
    }

    fn execute_send_midi(
        &mut self,
        port: &str,
        message_type: MidiMessageType,
        channel: u8,
        params: &MidiMessageParams,
        trigger_velocity: Option<u8>,  // NEW: pass trigger velocity
    ) -> Result<()> {
        use crate::velocity::calculate_velocity;  // NEW import

        match params {
            MidiMessageParams::Note { note, velocity_mapping } => {
                // Calculate actual velocity based on mapping and trigger
                let output_velocity = if let Some(trigger_vel) = trigger_velocity {
                    calculate_velocity(trigger_vel, velocity_mapping)
                } else {
                    // No trigger velocity available, use fallback
                    match velocity_mapping {
                        VelocityMapping::Fixed { velocity } => *velocity,
                        _ => 100,  // Default to mid-high velocity
                    }
                };

                // Send MIDI message with calculated velocity
                self.midi_output.send_note(port, channel, *note, output_velocity)?;
            }
            // ... other params
        }
        Ok(())
    }
}
```

---

### 4. Mapping Engine Updates

```rust
// midimon-core/src/mapping.rs (modifications)

impl MappingEngine {
    pub fn handle_event(&mut self, event: ProcessedEvent) -> Vec<Action> {
        let trigger_velocity = match &event {
            ProcessedEvent::PadPressed { velocity, .. } => Some(*velocity),
            _ => None,
        };

        let actions = self.find_matching_actions(&event);

        // Store trigger velocity for execution
        for action in &actions {
            if let Action::SendMidi { .. } = action {
                // Store velocity for later execution
                self.last_trigger_velocity = trigger_velocity;
            }
        }

        actions
    }
}
```

---

### 5. Configuration Syntax (TOML)

```toml
# v2.2 Variable Velocity Configuration Examples

# Example 1: Pass-through mode (preserve dynamics)
[[modes.mappings]]
trigger = { type = "Note", note = 36 }
action = {
  type = "SendMidi",
  port = "IAC Driver Bus 1",
  message_type = "note_on",
  channel = 0,
  note = 60,
  velocity_mapping = "PassThrough"
}

# Example 2: Linear scaling (limit range to 50-100)
[[modes.mappings]]
trigger = { type = "Note", note = 37 }
action = {
  type = "SendMidi",
  port = "IAC Driver Bus 1",
  message_type = "note_on",
  channel = 0,
  note = 61,
  velocity_mapping = { Linear = { min = 50, max = 100 } }
}

# Example 3: Fixed velocity (current behavior, backward compatible)
[[modes.mappings]]
trigger = { type = "Note", note = 38 }
action = {
  type = "SendMidi",
  port = "IAC Driver Bus 1",
  message_type = "note_on",
  channel = 0,
  note = 62,
  velocity_mapping = { Fixed = { velocity = 100 } }
}

# Example 4: Exponential curve (make soft hits louder)
[[modes.mappings]]
trigger = { type = "Note", note = 39 }
action = {
  type = "SendMidi",
  port = "IAC Driver Bus 1",
  message_type = "note_on",
  channel = 0,
  note = 63,
  velocity_mapping = {
    Curve = {
      curve_type = "Exponential",
      intensity = 0.5
    }
  }
}
```

---

### 6. GUI Components

#### VelocityMappingSelector Component

**File**: `midimon-gui/ui/src/lib/components/VelocityMappingSelector.svelte` (NEW)

**Features**:
- Mode selector: Fixed / Pass-Through / Linear / Curve
- Dynamic parameter fields based on mode
- Visual preview graph showing input → output mapping
- Real-time curve visualization

**Props**:
```javascript
export let velocityMapping = { type: 'Fixed', velocity: 100 };
export let readonly = false;
```

**Events**:
```javascript
dispatch('change', { mapping })
```

**UI Layout**:
```
┌─────────────────────────────────────────────┐
│  Velocity Mapping                           │
│  ┌────────────────────────────────────────┐ │
│  │ [Dropdown: Fixed/PassThrough/Linear/  │ │
│  │            Curve]                       │ │
│  └────────────────────────────────────────┘ │
│                                             │
│  {#if mode === 'Fixed'}                     │
│    Velocity: [Slider 0-127] [100]          │
│  {/if}                                      │
│                                             │
│  {#if mode === 'Linear'}                    │
│    Min: [Slider 0-127] [50]                │
│    Max: [Slider 0-127] [100]               │
│  {/if}                                      │
│                                             │
│  {#if mode === 'Curve'}                     │
│    Curve: [Dropdown: Exponential/Log/S]    │
│    Intensity: [Slider 0.0-1.0] [0.5]       │
│  {/if}                                      │
│                                             │
│  Preview:                                   │
│  ┌──────────────────────────────────────┐  │
│  │ 127│                        ╱         │  │
│  │    │                      ╱           │  │
│  │  63│                    ╱             │  │
│  │    │                  ╱               │  │
│  │   0└─────────────────┘                │  │
│  │     0       63      127               │  │
│  │     Input Velocity →                  │  │
│  └──────────────────────────────────────┘  │
└─────────────────────────────────────────────┘
```

---

#### Integration into SendMidiActionEditor

**File**: `midimon-gui/ui/src/lib/components/SendMidiActionEditor.svelte` (MODIFY)

Replace fixed velocity slider with VelocityMappingSelector:

```svelte
<!-- OLD: Fixed velocity slider -->
<!-- {#if config.message_type === 'note_on'}
  <input type="range" min="0" max="127" bind:value={config.velocity} />
{/if} -->

<!-- NEW: Variable velocity mapping -->
{#if config.message_type === 'note_on' || config.message_type === 'note_off'}
  <VelocityMappingSelector
    bind:velocityMapping={config.velocity_mapping}
    {readonly}
    on:change={handleFieldChange}
  />
{/if}
```

---

## Implementation Plan

### Phase 1: Backend (2 days)

**Task 1.1: Core Data Structures** (4 hours)
- [ ] Create `VelocityMapping` enum in `actions.rs`
- [ ] Create `VelocityCurve` enum
- [ ] Update `MidiMessageParams::Note` to use `velocity_mapping`
- [ ] Add `Serialize`/`Deserialize` derives

**Task 1.2: Velocity Calculation Engine** (4 hours)
- [ ] Create `midimon-core/src/velocity.rs`
- [ ] Implement `calculate_velocity()` function
- [ ] Implement `apply_curve()` for curve transformations
- [ ] Write unit tests (10+ test cases)

**Task 1.3: Action Execution** (4 hours)
- [ ] Update `ActionExecutor::execute()` to accept `trigger_velocity`
- [ ] Update `execute_send_midi()` to calculate velocity
- [ ] Update mapping engine to pass trigger velocity
- [ ] Integration tests for velocity calculation

**Task 1.4: Config Parsing** (4 hours)
- [ ] Update `ActionConfig::SendMidi` deserialization
- [ ] Support new TOML syntax for velocity mapping
- [ ] Add validation for velocity mapping configs
- [ ] Backward compatibility tests (old configs still work)

---

### Phase 2: Frontend (1.5 days)

**Task 2.1: VelocityMappingSelector Component** (8 hours)
- [ ] Create Svelte component with mode selector
- [ ] Implement dynamic parameter fields
- [ ] Create velocity preview graph (canvas-based)
- [ ] Add curve visualization
- [ ] Component styling (match existing dark theme)

**Task 2.2: SendMidiActionEditor Integration** (4 hours)
- [ ] Replace fixed velocity slider with VelocityMappingSelector
- [ ] Update default config to use `Fixed` mode
- [ ] Update validation logic
- [ ] Update event handlers

**Task 2.3: API Integration** (2 hours)
- [ ] Update Tauri commands to handle velocity_mapping
- [ ] Update validation command
- [ ] Test end-to-end flow

---

### Phase 3: Testing & Documentation (0.5 days)

**Task 3.1: Manual Testing** (2 hours)
- [ ] Test all 4 velocity modes (Fixed, PassThrough, Linear, Curve)
- [ ] Test all 3 curve types (Exponential, Log, S-curve)
- [ ] Test with real MIDI devices (pad controller → DAW)
- [ ] Verify velocity values in MIDI monitor

**Task 3.2: Documentation** (2 hours)
- [ ] Update user guide with Variable Velocity examples
- [ ] Add troubleshooting section
- [ ] Create tutorial: "Setting Up Dynamic Drums"
- [ ] Update CHANGELOG.md

---

## Testing Strategy

### Unit Tests

```rust
#[cfg(test)]
mod tests {
    // Test 1: Fixed velocity always returns same value
    // Test 2: PassThrough preserves trigger velocity
    // Test 3: Linear scaling maps correctly
    // Test 4: Exponential curve increases soft hits
    // Test 5: Logarithmic curve decreases soft hits
    // Test 6: S-curve creates smooth transitions
    // Test 7: Clamping to 0-127 range
    // Test 8: Edge cases (0, 127 input)
    // Test 9: Backward compatibility (old configs)
    // Test 10: Deserialization from TOML
}
```

### Integration Tests

```rust
#[test]
fn test_variable_velocity_execution() {
    // 1. Create mapping with PassThrough velocity
    // 2. Trigger with velocity 80
    // 3. Verify MIDI output velocity = 80
}

#[test]
fn test_linear_scaling_execution() {
    // 1. Create mapping with Linear { min: 50, max: 100 }
    // 2. Trigger with velocity 0, 63, 127
    // 3. Verify output velocities: 50, 75, 100
}
```

### Manual Testing Checklist

- [ ] GUI component renders correctly
- [ ] Mode changes update parameter fields
- [ ] Preview graph displays correct curve
- [ ] Config saves to TOML with correct syntax
- [ ] Config loads from TOML correctly
- [ ] MIDI output velocity matches expected values
- [ ] Trigger velocity from pad controller → output velocity in DAW
- [ ] All curve types work as expected
- [ ] Backward compatibility (old configs load)

---

## Backward Compatibility

### Strategy

**Goal**: Existing v2.1 configs must continue to work without modification.

**Approach**:
1. **Deserialize old `velocity: u8` as `Fixed` mode**
   ```rust
   // Old TOML syntax
   action = { type = "SendMidi", velocity = 100 }

   // Deserializes to
   velocity_mapping = VelocityMapping::Fixed { velocity: 100 }
   ```

2. **Custom deserializer**:
   ```rust
   impl<'de> Deserialize<'de> for MidiMessageParams {
       fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
       where
           D: Deserializer<'de>,
       {
           // Try new format first, fall back to old format
       }
   }
   ```

3. **Migration path**:
   - Old configs automatically upgrade on load
   - GUI displays as "Fixed" mode with original velocity
   - User can change to other modes if desired

---

## Performance Considerations

### Velocity Calculation Overhead

**Benchmark Results** (estimated):
- Fixed: 0.1 µs (simple field access)
- PassThrough: 0.1 µs (simple field access)
- Linear: 0.5 µs (1 division, 1 multiply, 1 add)
- Exponential: 2-5 µs (power function)
- Logarithmic: 2-5 µs (log function)
- S-curve: 3-6 µs (exp function)

**Impact**: Negligible (<10 µs per event, well within <1ms response target)

### Optimization Strategies

1. **Lookup Table** (future optimization):
   - Pre-calculate 128 velocity values for each curve
   - O(1) lookup instead of calculation
   - Trade-off: 128 bytes memory per mapping

2. **Integer Math** (future optimization):
   - Replace floating-point with fixed-point math
   - Faster on some platforms, but less precision

---

## Future Enhancements (v2.3+)

1. **Custom Curves**: User-defined velocity curves with curve editor
2. **Value Mapping for CC**: Apply same logic to CC values
3. **Multi-Point Curves**: Bezier curves with control points
4. **Velocity Templates**: Save/load velocity mapping presets
5. **Velocity Randomization**: Add random variation to velocity
6. **Velocity Limiting**: Min/max velocity independent of mapping
7. **Velocity Compression**: Compress dynamic range (make everything similar)
8. **Velocity Expansion**: Expand dynamic range (exaggerate differences)

---

## Conclusion

Variable Velocity is a high-value feature that enables expressive MIDI control, a core use case for MIDIMon users who want to use their controllers with DAWs and virtual instruments.

**Implementation Estimate**: 3-4 days
- Backend: 2 days
- Frontend: 1.5 days
- Testing/Docs: 0.5 days

**Risk Assessment**: LOW
- Well-defined scope
- Clear architecture
- No external dependencies
- Backward compatible
- Incremental implementation

**Next Step**: Begin Phase 1 implementation (Backend).

---

*End of Variable Velocity Design Document*
