# v2.1 Virtual MIDI Output - Technical Design

**Version**: v2.1.0
**Date**: 2025-01-17
**Status**: Design Phase

---

## Executive Summary

v2.1 adds virtual MIDI output capability to MIDIMon, enabling users to control DAWs and other MIDI software by creating virtual MIDI ports and sending MIDI messages through actions. This feature transforms MIDIMon from a pure input processor into a bidirectional MIDI controller.

**Key Features**:
- Virtual MIDI port creation (macOS/Linux only - Windows limitation in midir)
- SendMIDI action type for Note, CC, Program Change, Pitch Bend messages
- MIDI message routing with buffering and timing precision
- GUI integration for MIDI output device management
- DAW control examples (Logic Pro, Ableton Live, FL Studio)

---

## Platform Support & Limitations

### Supported Platforms
✅ **macOS** - CoreMIDI virtual sources (primary target)
✅ **Linux** - ALSA/JACK virtual ports
❌ **Windows** - midir does not support virtual ports

### Windows Workaround Strategy
For Windows users, we'll document third-party virtual MIDI drivers:
- loopMIDI (https://www.tobias-erichsen.de/software/loopmidi.html)
- virtualMIDI SDK
- Users can create virtual ports externally and MIDIMon will send to them as regular output ports

---

## Architecture Design

### 1. Core Components

#### 1.1 MIDI Output Manager (`midimon-core/src/midi_output.rs`)

```rust
/// MIDI output port manager
pub struct MidiOutputManager {
    /// midir MidiOutput instance
    midi_out: MidiOutput,

    /// Active output connections (port name → connection)
    connections: HashMap<String, MidiOutputConnection>,

    /// Virtual ports created by MIDIMon
    virtual_ports: HashMap<String, VirtualMidiPort>,

    /// Message queue for async sending
    message_queue: Arc<Mutex<VecDeque<MidiMessage>>>,
}

/// Represents a virtual MIDI port
pub struct VirtualMidiPort {
    name: String,
    connection: MidiOutputConnection,
    created_at: std::time::Instant,
}

/// MIDI message to be sent
#[derive(Debug, Clone)]
pub struct MidiMessage {
    /// MIDI message bytes
    pub data: Vec<u8>,

    /// Optional timestamp for precise timing
    pub timestamp: Option<std::time::Instant>,

    /// Target port name
    pub port_name: String,
}

impl MidiOutputManager {
    /// Create a new MIDI output manager
    pub fn new() -> Result<Self, MidiError>;

    /// Create a virtual MIDI port (macOS/Linux only)
    #[cfg(not(target_os = "windows"))]
    pub fn create_virtual_port(&mut self, name: &str) -> Result<(), MidiError>;

    /// Connect to an existing MIDI output port
    pub fn connect_to_port(&mut self, port_index: usize) -> Result<String, MidiError>;

    /// List available output ports
    pub fn list_output_ports(&self) -> Vec<String>;

    /// Send MIDI message immediately
    pub fn send_message(&mut self, port_name: &str, message: &[u8]) -> Result<(), MidiError>;

    /// Queue MIDI message for async sending
    pub fn queue_message(&mut self, message: MidiMessage);

    /// Process message queue (called from event loop)
    pub fn process_queue(&mut self) -> Result<usize, MidiError>;

    /// Disconnect from a port
    pub fn disconnect(&mut self, port_name: &str) -> Result<(), MidiError>;

    /// Disconnect all ports
    pub fn disconnect_all(&mut self);
}
```

#### 1.2 SendMIDI Action (`midimon-core/src/actions.rs`)

```rust
/// SendMIDI action configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendMidiAction {
    /// Target output port name
    pub port: String,

    /// MIDI message type
    pub message_type: MidiMessageType,

    /// Channel (0-15)
    pub channel: u8,

    /// Message-specific parameters
    pub params: MidiMessageParams,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MidiMessageType {
    NoteOn,
    NoteOff,
    ControlChange,
    ProgramChange,
    PitchBend,
    Aftertouch,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MidiMessageParams {
    Note { note: u8, velocity: u8 },
    CC { controller: u8, value: u8 },
    ProgramChange { program: u8 },
    PitchBend { value: i16 },  // -8192 to +8191
    Aftertouch { pressure: u8 },
}

impl SendMidiAction {
    /// Convert to raw MIDI bytes
    pub fn to_midi_bytes(&self) -> Vec<u8>;

    /// Validate parameters
    pub fn validate(&self) -> Result<(), ActionError>;
}
```

#### 1.3 Action Executor Integration (`midimon-daemon/src/action_executor.rs`)

```rust
impl ActionExecutor {
    /// Execute SendMIDI action
    fn execute_send_midi(&mut self, action: &SendMidiAction) -> Result<(), ActionError> {
        // Validate action
        action.validate()?;

        // Get MIDI output manager
        let midi_out = self.midi_output_manager
            .as_mut()
            .ok_or(ActionError::MidiOutputNotAvailable)?;

        // Convert to MIDI bytes
        let message_bytes = action.to_midi_bytes();

        // Send message
        midi_out.send_message(&action.port, &message_bytes)?;

        Ok(())
    }
}
```

---

## 2. Configuration Schema

### TOML Configuration

```toml
# Example: Logic Pro Play/Pause
[[modes.mappings]]
description = "Logic Pro - Play/Pause"

[modes.mappings.trigger]
type = "Note"
note = 1

[modes.mappings.action]
type = "SendMidi"
port = "MIDIMon Virtual Out"  # Virtual port created by MIDIMon
message_type = "ControlChange"
channel = 0
controller = 7   # Logic Pro transport control
value = 127

# Example: Ableton Live - Scene Launch
[[modes.mappings]]
description = "Ableton Live - Launch Scene 1"

[modes.mappings.trigger]
type = "Note"
note = 2

[modes.mappings.action]
type = "SendMidi"
port = "MIDIMon Virtual Out"
message_type = "Note"
channel = 0
note = 64      # Ableton Live scene trigger
velocity = 127
```

---

## 3. MIDI Message Construction

### Message Format Reference

```rust
// Note On:  [0x90 | channel, note, velocity]
// Note Off: [0x80 | channel, note, velocity]
// CC:       [0xB0 | channel, controller, value]
// Program:  [0xC0 | channel, program]
// Pitch:    [0xE0 | channel, lsb, msb]

impl SendMidiAction {
    pub fn to_midi_bytes(&self) -> Vec<u8> {
        let status_byte = match self.message_type {
            MidiMessageType::NoteOn => 0x90 | (self.channel & 0x0F),
            MidiMessageType::NoteOff => 0x80 | (self.channel & 0x0F),
            MidiMessageType::ControlChange => 0xB0 | (self.channel & 0x0F),
            MidiMessageType::ProgramChange => 0xC0 | (self.channel & 0x0F),
            MidiMessageType::PitchBend => 0xE0 | (self.channel & 0x0F),
            MidiMessageType::Aftertouch => 0xD0 | (self.channel & 0x0F),
        };

        match &self.params {
            MidiMessageParams::Note { note, velocity } => {
                vec![status_byte, *note & 0x7F, *velocity & 0x7F]
            }
            MidiMessageParams::CC { controller, value } => {
                vec![status_byte, *controller & 0x7F, *value & 0x7F]
            }
            MidiMessageParams::ProgramChange { program } => {
                vec![status_byte, *program & 0x7F]
            }
            MidiMessageParams::PitchBend { value } => {
                let bend_value = (*value + 8192) as u16;  // Convert to 0-16383
                let lsb = (bend_value & 0x7F) as u8;
                let msb = ((bend_value >> 7) & 0x7F) as u8;
                vec![status_byte, lsb, msb]
            }
            MidiMessageParams::Aftertouch { pressure } => {
                vec![status_byte, *pressure & 0x7F]
            }
        }
    }
}
```

---

## 4. GUI Integration

### 4.1 Tauri Commands (`midimon-gui/src-tauri/src/commands.rs`)

```rust
#[tauri::command]
pub async fn list_midi_output_ports() -> Result<Vec<String>, String> {
    // List available MIDI output ports
}

#[tauri::command]
pub async fn create_virtual_midi_port(name: String) -> Result<(), String> {
    // Create a virtual MIDI port (macOS/Linux only)
}

#[tauri::command]
pub async fn test_midi_output(
    port: String,
    message_type: String,
    channel: u8,
    note: u8,
    velocity: u8,
) -> Result<(), String> {
    // Test MIDI output by sending a single message
}
```

### 4.2 Svelte Components

**MidiOutputSelector.svelte**
- Dropdown to select MIDI output port
- Button to create virtual port (disabled on Windows)
- Port status indicator (connected/disconnected)

**SendMidiActionEditor.svelte**
- Message type selector (Note/CC/Program/Pitch/Aftertouch)
- Channel selector (1-16)
- Parameter inputs (note, velocity, controller, value, etc.)
- Test button to send message immediately

---

## 5. Testing Strategy

### 5.1 Unit Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_midi_message_construction() {
        let action = SendMidiAction {
            port: "Test Port".to_string(),
            message_type: MidiMessageType::NoteOn,
            channel: 0,
            params: MidiMessageParams::Note { note: 60, velocity: 100 },
        };

        let bytes = action.to_midi_bytes();
        assert_eq!(bytes, vec![0x90, 60, 100]);
    }

    #[test]
    fn test_pitch_bend_conversion() {
        let action = SendMidiAction {
            port: "Test".to_string(),
            message_type: MidiMessageType::PitchBend,
            channel: 0,
            params: MidiMessageParams::PitchBend { value: 0 },
        };

        let bytes = action.to_midi_bytes();
        // 0 should map to 8192 (center position)
        assert_eq!(bytes, vec![0xE0, 0x00, 0x40]);
    }

    #[test]
    #[cfg(not(target_os = "windows"))]
    fn test_virtual_port_creation() {
        let mut manager = MidiOutputManager::new().unwrap();
        manager.create_virtual_port("Test Virtual Port").unwrap();

        // Verify port was created
        assert!(manager.virtual_ports.contains_key("Test Virtual Port"));
    }
}
```

### 5.2 Integration Tests

- Create virtual port → Send messages → Verify loopback reception
- Test all message types with various parameter values
- Test multiple simultaneous output connections
- Test error handling (invalid ports, invalid parameters)

---

## 6. Documentation Requirements

### User Documentation (`docs-site/src/guides/daw-control.md`)

1. **Overview**: What is virtual MIDI output and why use it
2. **Platform Notes**: macOS/Linux support, Windows workarounds
3. **Creating Virtual Ports**: Step-by-step GUI walkthrough
4. **SendMIDI Action**: Configuration reference with examples
5. **DAW-Specific Guides**:
   - Logic Pro setup and common controls
   - Ableton Live scene launching and transport
   - FL Studio patterns and mixer control

### Configuration Reference (`docs-site/src/configuration/actions.md`)

Add SendMIDI action type documentation:
- All message types with parameter descriptions
- MIDI channel explanation (0-15 vs 1-16)
- Value ranges and constraints
- Complete TOML examples

---

## 7. Implementation Plan (2 Weeks)

### Week 1: Core Implementation

**Day 1-2**: MIDI Output Manager
- Implement `MidiOutputManager` struct
- Add virtual port creation (macOS/Linux)
- Add connection management
- Write unit tests

**Day 3-4**: SendMIDI Action
- Add `SendMidiAction` to actions.rs
- Implement MIDI message construction
- Integrate with ActionExecutor
- Write message construction tests

**Day 5**: Integration & Testing
- Integration tests with virtual loopback
- Manual testing with DAW software
- Platform-specific testing (macOS primary)

### Week 2: GUI & Documentation

**Day 6-7**: Tauri Commands
- Implement list/create/test commands
- Add MIDI output state management
- Error handling and validation

**Day 8-9**: Svelte Components
- MidiOutputSelector component
- SendMidiActionEditor component
- Integration into DevicesView and MappingsView

**Day 10**: DAW Examples
- Create Logic Pro example config
- Create Ableton Live example config
- Create FL Studio example config
- Test with actual DAW software

**Day 11-12**: Documentation
- Write DAW control guide
- Update configuration reference
- Add troubleshooting section
- Record demo video/GIFs

---

## 8. Success Criteria

✅ **Functional Requirements**:
- Virtual MIDI ports created successfully on macOS
- All 6 message types (Note, CC, Program, Pitch, Aftertouch) work correctly
- GUI allows selecting output ports and configuring SendMIDI actions
- <1ms latency for MIDI message sending
- DAW control examples work with Logic Pro and Ableton Live

✅ **Quality Requirements**:
- 85%+ test coverage for MIDI output code
- All unit tests passing
- Integration tests with loopback passing
- Zero memory leaks or panics
- Documentation complete with examples

✅ **Non-Functional Requirements**:
- Platform detection warns Windows users about limitations
- Error messages guide users to workarounds
- MIDI output doesn't interfere with MIDI input performance

---

## 9. Risk Mitigation

### Risk 1: Windows No Virtual Port Support
**Mitigation**: Document third-party virtual MIDI drivers (loopMIDI), provide clear setup instructions

### Risk 2: DAW-Specific MIDI Implementation Differences
**Mitigation**: Test with actual DAWs early, create flexible examples that users can customize

### Risk 3: MIDI Timing Precision
**Mitigation**: Use message queue with optional timestamps, allow configurable buffering

### Risk 4: Multiple Output Connections Performance
**Mitigation**: Profile early, use async message queue if needed, limit simultaneous connections

---

## 10. Future Enhancements (v2.2+)

- MIDI output templates for popular DAWs
- MIDI Learn for discovering DAW MIDI mappings
- MIDI routing matrix (input → multiple outputs)
- SysEx message support
- MIDI clock/sync output
- Note duration control (auto Note Off after delay)

---

**Design Status**: ✅ READY FOR IMPLEMENTATION
**Next Step**: Begin Week 1 Day 1 - Implement MidiOutputManager
