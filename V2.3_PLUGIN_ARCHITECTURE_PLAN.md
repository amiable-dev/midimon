# v2.3 Plugin Architecture - Implementation Plan

**Version**: v2.3.0
**Phase**: Phase 5, Milestone 3
**Status**: Planning
**Created**: 2025-11-18
**Target Start**: After v2.2.0 validation complete
**Estimated Duration**: 4-6 weeks

---

## Executive Summary

v2.3 introduces a **Plugin Architecture** that enables third-party extensibility for MIDIMon. This feature allows developers to create custom actions and triggers without modifying the core codebase.

**Key Features**:
- ActionPlugin trait for custom actions
- TriggerPlugin trait for custom event sources
- Plugin discovery and lifecycle management
- Security measures (sandboxing, signatures, permissions)
- Example plugins (HTTP, Spotify, Home Automation)
- Plugin Manager GUI for installation and configuration
- Comprehensive developer documentation

**Strategic Value**: Unlocks community-driven feature development, enabling MIDIMon to support any service, API, or automation without core team bottleneck.

---

## Prerequisites

### Completed Milestones
- ✅ v2.1.0: Virtual MIDI Output (released 2025-11-17)
- ✅ v2.2.0: Velocity Curves & Advanced Conditionals (released 2025-11-18)
- ✅ Phase 4: Tauri GUI (v2.0.0 complete)

### Infrastructure Requirements
- ✅ midimon-core: Pure engine library with Action trait system
- ✅ midimon-daemon: Background service with ActionExecutor
- ✅ midimon-gui: Tauri v2 GUI with component framework
- ✅ Build system: Cargo workspace with 3 crates
- ✅ Test infrastructure: 145+ tests passing

### Technical Foundation
- ✅ Action execution framework in ActionExecutor
- ✅ Configuration system with TOML parsing
- ✅ Error handling with EngineError types
- ✅ Documentation site with mdbook

---

## Goals & Success Criteria

### Functional Goals
- [ ] Plugin API is stable and well-documented
- [ ] Example plugins demonstrate all capabilities
- [ ] Plugin manager UI is functional and intuitive
- [ ] Security measures prevent malicious plugins
- [ ] Developer documentation enables third-party development

### Technical Goals
- [ ] Plugin loading adds <5ms overhead
- [ ] Plugins execute in isolated contexts
- [ ] Plugin errors don't crash daemon
- [ ] 85%+ test coverage for plugin system
- [ ] Zero regressions in existing functionality

### Community Goals
- [ ] Plugin template project available
- [ ] 3+ example plugins shipped with v2.3
- [ ] Developer guide enables first plugin in <2 hours
- [ ] Plugin submission guidelines published

---

## Architecture Design

### Plugin System Components

```
┌──────────────────────────────────────────────────┐
│  midimon-gui (Tauri)                             │
│  ┌────────────────────────────────────────────┐ │
│  │  Plugin Manager UI                         │ │
│  │  - Browse/search plugins                   │ │
│  │  - Install/uninstall                       │ │
│  │  - Enable/disable                          │ │
│  │  - Configure plugin settings               │ │
│  └────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────┘
             │
             ▼ IPC (Tauri commands)
┌──────────────────────────────────────────────────┐
│  midimon-daemon                                  │
│  ┌────────────────────────────────────────────┐ │
│  │  Plugin Manager                            │ │
│  │  - Load/unload plugins                     │ │
│  │  - Validate signatures                     │ │
│  │  - Manage plugin lifecycle                 │ │
│  └────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────┐ │
│  │  Action Executor (Enhanced)                │ │
│  │  - Route to core actions OR plugin actions │ │
│  │  - Execute plugin actions                  │ │
│  │  - Handle plugin errors                    │ │
│  └────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────┘
             │
             ▼
┌──────────────────────────────────────────────────┐
│  midimon-core                                    │
│  ┌────────────────────────────────────────────┐ │
│  │  Plugin Traits                             │ │
│  │  - ActionPlugin trait                      │ │
│  │  - TriggerPlugin trait                     │ │
│  │  - PluginMetadata                          │ │
│  └────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────┘
             │
             ▼
┌──────────────────────────────────────────────────┐
│  Plugins (external .so/.dylib/.dll)              │
│  ┌─────────────┬─────────────┬────────────────┐ │
│  │ HTTP Plugin │ Spotify     │ Home Automation│ │
│  │ (example)   │ Plugin      │ Plugin (MQTT)  │ │
│  └─────────────┴─────────────┴────────────────┘ │
└──────────────────────────────────────────────────┘
```

### Plugin API Design

#### ActionPlugin Trait

```rust
// midimon-core/src/plugin/action_plugin.rs

use serde_json::Value;
use std::error::Error;

/// Trait for custom action plugins
pub trait ActionPlugin: Send + Sync {
    /// Plugin identifier (unique, lowercase, alphanumeric + underscore)
    fn name(&self) -> &str;

    /// Semantic version (e.g., "1.0.0")
    fn version(&self) -> &str;

    /// Human-readable description
    fn description(&self) -> &str;

    /// Execute the plugin action with given parameters
    fn execute(&mut self, params: Value, context: TriggerContext) -> Result<(), Box<dyn Error>>;

    /// JSON Schema for plugin configuration validation
    fn config_schema(&self) -> Schema;

    /// Optional: Plugin capabilities (e.g., "network", "filesystem", "audio")
    fn capabilities(&self) -> Vec<Capability> {
        vec![]
    }

    /// Optional: Initialize plugin (called once after load)
    fn initialize(&mut self) -> Result<(), Box<dyn Error>> {
        Ok(())
    }

    /// Optional: Cleanup plugin (called before unload)
    fn shutdown(&mut self) -> Result<(), Box<dyn Error>> {
        Ok(())
    }
}

/// Trigger context passed to plugin execute()
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TriggerContext {
    /// MIDI velocity (0-127) if trigger was velocity-sensitive
    pub velocity: Option<u8>,

    /// Current mode index
    pub current_mode: Option<usize>,

    /// Timestamp of trigger event
    pub timestamp: std::time::Instant,
}

/// Plugin capability flags for permission system
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Capability {
    Network,        // Can make HTTP/HTTPS requests
    Filesystem,     // Can read/write files
    Audio,          // Can access audio devices
    MIDI,           // Can send/receive MIDI
    Subprocess,     // Can spawn processes
    SystemControl,  // Can control system (volume, display, etc.)
}
```

#### TriggerPlugin Trait

```rust
// midimon-core/src/plugin/trigger_plugin.rs

/// Trait for custom trigger plugins (future feature)
pub trait TriggerPlugin: Send + Sync {
    /// Plugin identifier
    fn name(&self) -> &str;

    /// Semantic version
    fn version(&self) -> &str;

    /// Human-readable description
    fn description(&self) -> &str;

    /// Start the trigger plugin (begin monitoring)
    fn start(&mut self) -> Result<(), Box<dyn Error>>;

    /// Stop the trigger plugin (stop monitoring)
    fn stop(&mut self) -> Result<(), Box<dyn Error>>;

    /// Poll for events (called periodically by daemon)
    fn poll_events(&mut self) -> Vec<PluginEvent>;

    /// JSON Schema for trigger configuration
    fn config_schema(&self) -> Schema;
}

/// Event emitted by trigger plugins
#[derive(Debug, Clone)]
pub struct PluginEvent {
    pub plugin_name: String,
    pub event_type: String,
    pub data: Value,
    pub timestamp: std::time::Instant,
}
```

#### Plugin Metadata

```rust
// midimon-core/src/plugin/metadata.rs

/// Plugin metadata (read from plugin manifest)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginMetadata {
    pub name: String,
    pub version: String,
    pub description: String,
    pub author: String,
    pub homepage: Option<String>,
    pub license: String,
    pub capabilities: Vec<Capability>,

    // Plugin binary info
    pub binary_path: PathBuf,
    pub checksum: String,  // SHA256 of binary
    pub signature: Option<String>,  // Ed25519 signature (future)
}
```

---

## Work Breakdown

### Week 1-2: Plugin API Design (8 days)

#### Day 1-3: ActionPlugin Trait & Loader
- [ ] **Create plugin module structure**
  - midimon-core/src/plugin/mod.rs
  - midimon-core/src/plugin/action_plugin.rs
  - midimon-core/src/plugin/trigger_plugin.rs
  - midimon-core/src/plugin/metadata.rs
  - midimon-core/src/plugin/loader.rs

- [ ] **Implement ActionPlugin trait**
  - Define trait methods (name, version, execute, config_schema, etc.)
  - Add TriggerContext struct
  - Add Capability enum

- [ ] **Implement plugin loader**
  - Dynamic library loading (libloading crate)
  - Symbol resolution for plugin entry points
  - Error handling for load failures
  - Plugin validation (version compatibility, required symbols)

- [ ] **Write unit tests**
  - Test plugin loading from .so/.dylib/.dll
  - Test execute() method invocation
  - Test error handling (missing symbols, invalid plugins)

**Deliverables**: ActionPlugin trait, PluginLoader, 15+ unit tests

#### Day 4-6: TriggerPlugin Trait & Loader
- [ ] **Implement TriggerPlugin trait**
  - Define trait methods (start, stop, poll_events, config_schema)
  - Add PluginEvent struct
  - Add event queue management

- [ ] **Extend plugin loader for triggers**
  - Support both ActionPlugin and TriggerPlugin
  - Plugin type detection
  - Lifecycle management (start/stop)

- [ ] **Write unit tests**
  - Test trigger plugin loading
  - Test event polling
  - Test start/stop lifecycle

**Deliverables**: TriggerPlugin trait, enhanced PluginLoader, 10+ unit tests

#### Day 7-8: Plugin Discovery & Metadata
- [ ] **Implement plugin discovery**
  - Scan plugins directory (~/.midimon/plugins/)
  - Parse plugin manifests (plugin.toml)
  - Build plugin registry

- [ ] **Create plugin manifest format**
  ```toml
  [plugin]
  name = "http_request"
  version = "1.0.0"
  description = "Make HTTP requests as actions"
  author = "MIDIMon Team"
  license = "MIT"
  type = "action"  # or "trigger"
  binary = "http_request.so"
  checksum = "sha256:..."

  [plugin.capabilities]
  network = true
  ```

- [ ] **Write discovery tests**
  - Test manifest parsing
  - Test plugin registry
  - Test duplicate detection

**Deliverables**: Plugin discovery system, manifest format, 8+ tests

---

### Week 3-4: Plugin Infrastructure (11 days)

#### Day 9-12: Plugin Manager Core
- [ ] **Create PluginManager struct** (midimon-daemon/src/plugin_manager.rs)
  - Install plugin (copy to plugins dir, validate)
  - Uninstall plugin (remove files, cleanup)
  - Enable/disable plugin (update config)
  - List installed plugins
  - Get plugin info

- [ ] **Implement plugin lifecycle**
  - Load plugins on daemon startup
  - Initialize plugins (call initialize())
  - Shutdown plugins on daemon exit
  - Hot-reload support (reload plugin without restart)

- [ ] **Add plugin state persistence**
  - Store enabled/disabled state
  - Store plugin configurations
  - Atomic updates to plugin state file

- [ ] **Write integration tests**
  - Test install/uninstall workflow
  - Test enable/disable
  - Test plugin state persistence

**Deliverables**: PluginManager, lifecycle management, 20+ tests

#### Day 13-15: Plugin Security
- [ ] **Implement permission system**
  - Check plugin capabilities before execute()
  - Prompt user for dangerous capabilities
  - Store permission grants in state file

- [ ] **Add checksum verification**
  - Calculate SHA256 of plugin binary
  - Compare against manifest checksum
  - Reject mismatched binaries

- [ ] **Add resource limits** (if feasible)
  - Timeout for plugin execute() (5 seconds default)
  - Memory limit monitoring (log warnings)
  - CPU usage tracking (future: kill runaway plugins)

- [ ] **Write security tests**
  - Test permission enforcement
  - Test checksum validation
  - Test timeout handling

**Deliverables**: Permission system, checksum verification, 12+ security tests

#### Day 16-19: ActionExecutor Integration
- [ ] **Extend ActionExecutor for plugins** (midimon-daemon/src/action_executor.rs)
  - Add PluginAction variant to Action enum
  - Route PluginAction to PluginManager
  - Pass TriggerContext to plugin execute()
  - Handle plugin errors gracefully (log, notify user)

- [ ] **Add plugin actions to config**
  ```toml
  [[modes.mappings]]
  [modes.mappings.trigger]
  type = "Note"
  note = 1

  [modes.mappings.action]
  type = "Plugin"
  plugin = "http_request"
  params = { url = "https://example.com/api", method = "POST" }
  ```

- [ ] **Write integration tests**
  - Test PluginAction execution
  - Test error handling
  - Test context propagation

**Deliverables**: ActionExecutor plugin support, 15+ integration tests

---

### Week 5: Example Plugins (6 days)

#### Day 20-21: HTTP Request Plugin
- [ ] **Create http_request plugin project**
  - New crate: plugins/http_request/
  - Implement ActionPlugin trait
  - Use reqwest for HTTP client

- [ ] **Features**:
  - GET/POST/PUT/DELETE requests
  - Custom headers
  - Request body (JSON, form-data)
  - Basic auth, Bearer token auth
  - Timeout configuration

- [ ] **Write tests & docs**
  - Unit tests for HTTP methods
  - Integration tests with test server
  - README with usage examples

**Deliverables**: HTTP plugin (300-400 lines), 10+ tests, README

#### Day 22-23: Spotify Plugin
- [ ] **Create spotify plugin project**
  - New crate: plugins/spotify/
  - Implement ActionPlugin trait
  - Use rspotify crate for Spotify API

- [ ] **Features**:
  - Play/Pause/Next/Previous
  - Volume control
  - Playlist selection
  - Currently playing info

- [ ] **OAuth setup**
  - Client ID/secret configuration
  - Token refresh mechanism
  - User authorization guide

- [ ] **Write tests & docs**
  - Mock Spotify API tests
  - README with setup guide

**Deliverables**: Spotify plugin (400-500 lines), 8+ tests, README

#### Day 24-25: Home Automation Plugin
- [ ] **Create home_automation plugin**
  - New crate: plugins/home_automation/
  - Implement ActionPlugin trait
  - Use rumqttc for MQTT client

- [ ] **Features**:
  - Publish MQTT messages
  - Home Assistant integration
  - MQTT broker configuration
  - Topic/payload customization

- [ ] **Write tests & docs**
  - MQTT broker tests
  - README with Home Assistant examples

**Deliverables**: Home automation plugin (300-400 lines), 6+ tests, README

---

### Week 6: GUI & Documentation (5 days)

#### Day 26-28: Plugin Manager UI
- [ ] **Create PluginManagerView.svelte**
  - List installed plugins (name, version, description, enabled status)
  - Plugin details view (capabilities, author, homepage)
  - Install plugin (file picker, drag-and-drop)
  - Uninstall plugin (confirmation dialog)
  - Enable/disable toggle

- [ ] **Create PluginConfigEditor.svelte**
  - Dynamic form based on plugin config_schema
  - JSON Schema to UI field mapping
  - Validation with error messages
  - Save/reset buttons

- [ ] **Add Tauri commands** (midimon-gui/src-tauri/src/commands.rs)
  ```rust
  #[tauri::command]
  async fn list_plugins() -> Result<Vec<PluginMetadata>, String>;

  #[tauri::command]
  async fn install_plugin(path: String) -> Result<(), String>;

  #[tauri::command]
  async fn uninstall_plugin(name: String) -> Result<(), String>;

  #[tauri::command]
  async fn enable_plugin(name: String) -> Result<(), String>;

  #[tauri::command]
  async fn get_plugin_config(name: String) -> Result<Value, String>;

  #[tauri::command]
  async fn save_plugin_config(name: String, config: Value) -> Result<(), String>;
  ```

- [ ] **Write E2E tests**
  - Test plugin list display
  - Test install workflow
  - Test configuration saving

**Deliverables**: Plugin Manager UI (800-1000 lines), 5 Tauri commands, E2E tests

#### Day 29-30: Developer Documentation
- [ ] **Create developer guide** (docs-site/src/developers/plugin-guide.md)
  - Plugin architecture overview
  - Creating your first plugin
  - ActionPlugin trait reference
  - TriggerPlugin trait reference
  - Testing plugins
  - Publishing plugins

- [ ] **Create API reference** (docs-site/src/developers/plugin-api.md)
  - ActionPlugin trait methods
  - TriggerContext struct
  - Capability enum
  - PluginMetadata
  - Error handling

- [ ] **Create security guide** (docs-site/src/developers/plugin-security.md)
  - Permission system
  - Capability requirements
  - Checksum generation
  - Best practices

- [ ] **Create plugin template project**
  - Template repository on GitHub
  - Minimal ActionPlugin example
  - Build script
  - README with quickstart

**Deliverables**: 3 documentation files (~2,000 lines), plugin template repo

---

## Testing Strategy

### Unit Tests (60+ tests)
- Plugin loader: 15 tests
- Trigger plugin: 10 tests
- Plugin discovery: 8 tests
- Plugin manager: 20 tests
- Security: 12 tests
- Example plugins: 24 tests (8 per plugin)

### Integration Tests (30+ tests)
- ActionExecutor plugin integration: 15 tests
- End-to-end plugin execution: 10 tests
- Plugin state persistence: 5 tests

### E2E Tests (GUI) (5+ tests)
- Plugin installation workflow
- Plugin configuration
- Plugin enable/disable

### Manual Testing Checklist
- [ ] Install HTTP plugin via GUI
- [ ] Configure HTTP plugin with test endpoint
- [ ] Trigger HTTP action via MIDI
- [ ] Verify HTTP request sent correctly
- [ ] Uninstall plugin, verify cleanup
- [ ] Test with all 3 example plugins

---

## Documentation Plan

### User Documentation
- [ ] **User guide**: "Using Plugins" (docs-site/src/guides/using-plugins.md)
  - Installing plugins
  - Configuring plugins
  - Using plugin actions in mappings
  - Troubleshooting plugins

### Developer Documentation
- [ ] **Plugin development guide** (docs-site/src/developers/plugin-guide.md)
- [ ] **ActionPlugin API reference** (docs-site/src/developers/action-plugin-api.md)
- [ ] **TriggerPlugin API reference** (docs-site/src/developers/trigger-plugin-api.md)
- [ ] **Plugin security guidelines** (docs-site/src/developers/plugin-security.md)

### Example Documentation
- [ ] **HTTP plugin README** (plugins/http_request/README.md)
- [ ] **Spotify plugin README** (plugins/spotify/README.md)
- [ ] **Home automation plugin README** (plugins/home_automation/README.md)

### Updated Files
- [ ] **Configuration actions reference** (docs-site/src/configuration/actions.md)
  - Add Plugin action type section

- [ ] **SUMMARY.md** - Add plugin documentation links

---

## Risk Analysis

### High Risks

1. **Plugin Security**
   - **Risk**: Malicious plugins could compromise system
   - **Impact**: Reputation damage, user data loss
   - **Mitigation**: Checksum verification, permission system, code review guidelines
   - **Contingency**: First-party plugins only for v2.3.0, third-party in v2.3.1 after security audit

2. **API Stability**
   - **Risk**: Breaking changes fragment ecosystem
   - **Impact**: Community frustration, plugin incompatibility
   - **Mitigation**: Extensive design review, semantic versioning, deprecation policy
   - **Contingency**: Maintain backward compat for v2.3.x series

### Medium Risks

3. **Performance Overhead**
   - **Risk**: Plugin loading/execution adds latency
   - **Impact**: User experience degradation
   - **Mitigation**: Benchmark plugin overhead, lazy loading, async execution
   - **Contingency**: Add "fast mode" that disables plugins

4. **Plugin Complexity**
   - **Risk**: Plugin API too complex for average developers
   - **Impact**: Low adoption, few community plugins
   - **Mitigation**: Clear examples, template project, visual plugin builder (future)
   - **Contingency**: Provide "Simple Plugin" API wrapper

### Low Risks

5. **Platform Compatibility**
   - **Risk**: Plugins may not work on all platforms
   - **Impact**: Inconsistent UX across platforms
   - **Mitigation**: Test plugins on macOS, Linux, Windows
   - **Contingency**: Document platform limitations clearly

---

## Success Metrics

### Launch Criteria (v2.3.0 Release)
- [ ] Plugin API implemented and tested (85%+ coverage)
- [ ] 3 example plugins shipped (HTTP, Spotify, Home Automation)
- [ ] Plugin Manager UI functional
- [ ] Developer documentation complete
- [ ] Plugin template project available
- [ ] All workspace tests passing (100%)
- [ ] Zero regressions from v2.2

### Post-Launch (3 months)
- [ ] 5+ community-contributed plugins
- [ ] 100+ plugin installs across user base
- [ ] <5 critical security issues reported
- [ ] Developer satisfaction >80% (survey)

---

## Timeline

### Optimistic (4 weeks)
- Week 1-2: Plugin API & Loader (8 days)
- Week 3-4: Infrastructure & Security (11 days)
- Week 5: Example Plugins (6 days)
- Week 6: GUI & Docs (5 days)
- **Total**: 30 days (4.3 weeks)

### Realistic (5 weeks)
- Week 1-2: Plugin API & Loader (10 days, +2 buffer)
- Week 3-4: Infrastructure & Security (13 days, +2 buffer)
- Week 5: Example Plugins (7 days, +1 buffer)
- Week 6: GUI & Docs (6 days, +1 buffer)
- **Total**: 36 days (5.1 weeks)

### Pessimistic (6 weeks)
- Week 1-2: Plugin API & Loader (12 days, +4 buffer)
- Week 3-4: Infrastructure & Security (15 days, +4 buffer)
- Week 5: Example Plugins (8 days, +2 buffer)
- Week 6-7: GUI & Docs (8 days, +3 buffer)
- **Total**: 43 days (6.1 weeks)

**Recommended**: Plan for **5 weeks** (realistic timeline)

---

## Dependencies

### External Crates Required
- `libloading` - Dynamic library loading
- `reqwest` - HTTP client (for HTTP plugin)
- `rspotify` - Spotify API (for Spotify plugin)
- `rumqttc` - MQTT client (for Home Automation plugin)
- `serde_json` - JSON handling for plugin configs
- `jsonschema` - JSON Schema validation (optional)

### Blocked By
- v2.2.0 release and validation (COMPLETE ✅)

### Blocking
- v2.4 Profile Marketplace (plugins should be shareable)

---

## Next Steps

### Immediate Actions (Next 48 Hours)
1. [ ] Create Linear epic for v2.3 Plugin Architecture
2. [ ] Create child issues for each work item (Week 1-6)
3. [ ] Set up plugin template repository skeleton
4. [ ] Create plugins/ directory in workspace
5. [ ] Research libloading API and dynamic linking

### Week 1 Kickoff
1. [ ] Review and approve v2.3 plan
2. [ ] Begin ActionPlugin trait implementation
3. [ ] Set up development environment for plugins
4. [ ] Create initial plugin loader prototype

---

## Appendix: Plugin Configuration Examples

### HTTP Request Plugin Config

```toml
[[modes.mappings]]
description = "Trigger webhook on pad press"

[modes.mappings.trigger]
type = "Note"
note = 1

[modes.mappings.action]
type = "Plugin"
plugin = "http_request"

[modes.mappings.action.params]
url = "https://api.example.com/webhook"
method = "POST"
headers = { "Content-Type" = "application/json", "Authorization" = "Bearer token123" }
body = { event = "pad_pressed", note = 1 }
timeout_ms = 5000
```

### Spotify Plugin Config

```toml
[[modes.mappings]]
description = "Play/pause Spotify"

[modes.mappings.trigger]
type = "Note"
note = 2

[modes.mappings.action]
type = "Plugin"
plugin = "spotify"

[modes.mappings.action.params]
action = "play_pause"
```

### Home Automation Plugin Config

```toml
[[modes.mappings]]
description = "Turn on lights"

[modes.mappings.trigger]
type = "Note"
note = 3

[modes.mappings.action]
type = "Plugin"
plugin = "home_automation"

[modes.mappings.action.params]
broker = "mqtt://192.168.1.100:1883"
topic = "home/living_room/lights/set"
payload = "ON"
qos = 1
```

---

**Status**: ✅ Planning Complete - Ready for Linear issue creation
**Next Review**: After Week 2 completion
**Last Updated**: 2025-11-18
